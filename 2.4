-- Ultra-Fast Optimized AutoParry Script with Anti-AFK, Improved Auto Attack, Anti-Curve, and Custom Ball Direction
local workspace = game:GetService("Workspace")
local players = game:GetService("Players")
local replicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local StarterGui = game:GetService("StarterGui")

local localPlayer = players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local ballsFolder = workspace:WaitForChild("Balls")
local parryButtonPress = replicatedStorage.Remotes.ParryButtonPress
local attackButtonPress = replicatedStorage.Remotes.AttackButtonPress

-- Load Optimized UI Library
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))()

-- Create UI Window
local Window = Rayfield:CreateWindow({
    Name = "AutoParry GUI",
    LoadingTitle = "Blade Ball AutoParry",
    LoadingSubtitle = "Ultra Fast Mode",
    ConfigurationSaving = {Enabled = false},
    KeySystem = false
})

local AutoParryTab = Window:CreateTab("AutoParry")
local SettingsSection = AutoParryTab:CreateSection("Settings")
local StatsSection = AutoParryTab:CreateSection("Performance Stats")

-- Constants (Extreme Reflex Mode)
local BASE_THRESHOLD = 0.05  -- Faster reflex time
local IMMEDIATE_PARRY_DISTANCE = 20  -- Increased auto-parry range
local IMMEDIATE_HIGH_VELOCITY_THRESHOLD = 100  -- Handles high-speed balls
local AUTO_ATTACK_THRESHOLD = 5  -- Immediate attack when ball is extremely close

-- Variables
local sliderValue = 30  -- Increased default parry distance
local isRunning = false
local autoAttack = true  -- Enabled by default
local antiAFK = true  -- Anti-AFK enabled by default
local ballDirection = "Forward"  -- Default direction for returning the ball

-- Optimized function to get closest ball instantly
local function getClosestBall()
    local bestBall = nil
    local minDistance = math.huge
    for _, ball in ipairs(ballsFolder:GetChildren()) do
        if ball:GetAttribute("realBall") then
            local distance = (ball.Position - character.PrimaryPart.Position).Magnitude
            if distance < minDistance then
                minDistance = distance
                bestBall = ball
            end
        end
    end
    return bestBall, minDistance
end

-- Anti-Curve Function
local function adjustParryDirection(ball)
    local velocity = ball.Velocity.Unit
    local correctionFactor = Vector3.new(-velocity.X * 0.8, 0, -velocity.Z * 0.8)  -- Adjust against curve
    return correctionFactor
end

-- FPS & Ping Display
local fpsLabel = StatsSection:CreateLabel("FPS: Calculating...")
local pingLabel = StatsSection:CreateLabel("Ping: Calculating...")

RunService.RenderStepped:Connect(function()
    local fps = math.floor(1 / RunService.RenderStepped:Wait())
    fpsLabel:Set("FPS: " .. fps)
    
    local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
    pingLabel:Set("Ping: " .. ping .. " ms")
end)

-- Main auto-parry logic with ultra-fast reflexes
RunService.Heartbeat:Connect(function()
    if not isRunning then return end

    local ball, distance = getClosestBall()
    local HRP = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not ball or not HRP then return end

    if ball:GetAttribute("target") == localPlayer.Name and distance <= IMMEDIATE_PARRY_DISTANCE then
        local correction = adjustParryDirection(ball)
        HRP.CFrame = HRP.CFrame + correction  -- Adjust player positioning to counter curve
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        Rayfield:Notify({Title = "AutoParry", Content = "Ultra-Fast Parry!", Duration = 0.3})
    end

    if autoAttack then
        if distance <= AUTO_ATTACK_THRESHOLD then
            for _ = 1, 3 do  -- Spam attack rapidly when ball is extremely close
                attackButtonPress:Fire()
                task.wait(0.05)
            end
        elseif distance <= sliderValue then
            attackButtonPress:Fire()
        end
    end
end)

-- Anti-AFK Function
local function enableAntiAFK()
    game:GetService("Players").LocalPlayer.Idled:Connect(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        Rayfield:Notify({Title = "Anti-AFK", Content = "Jumped to prevent AFK kick!", Duration = 1})
    end)
end

if antiAFK then
    enableAntiAFK()
end

-- UI Elements
local AutoParryToggle = AutoParryTab:CreateToggle({
    Name = "Enable AutoParry (Ultra-Fast)",
    CurrentValue = false,
    Callback = function(value)
        isRunning = value
        Rayfield:Notify({Title = "AutoParry", Content = value and "Activated" or "Deactivated", Duration = 1})
    end
})

local DistanceSlider = AutoParryTab:CreateSlider({
    Name = "Parry Distance",
    Range = {10, 50},
    Increment = 1,
    CurrentValue = sliderValue,
    Callback = function(value)
        sliderValue = value
    end
})

local BallDirectionDropdown = AutoParryTab:CreateDropdown({
    Name = "Ball Return Direction",
    Options = {"Forward", "Left", "Right", "Random"},
    CurrentOption = ballDirection,
    Callback = function(value)
        ballDirection = value
    end
})

local AutoAttackToggle = AutoParryTab:CreateToggle({
    Name = "Auto Attack After Parry",
    CurrentValue = autoAttack,
    Callback = function(value)
        autoAttack = value
    end
})

local AntiAFKToggle = AutoParryTab:CreateToggle({
    Name = "Enable Anti-AFK",
    CurrentValue = antiAFK,
    Callback = function(value)
        antiAFK = value
        if value then
            enableAntiAFK()
        end
    end
})

-- Event bindings
localPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.One then isRunning = true end
    if input.KeyCode == Enum.KeyCode.Two then isRunning = false end
end)
